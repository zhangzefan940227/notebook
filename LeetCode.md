代码随想录算法训练营第二十八天|93. 复原 IP 地址,78. 子集


# 93. 复原 IP 地址

## 题目

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

示例 1：

输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]

示例 2：

输入：s = "0000"
输出：["0.0.0.0"]

示例 3：

输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]

## 解题思路

- 与题目131类似，比131题多的是要在字符串中增加 `.` 符号，且数量固定为3，只有这样才能将字符串分割成四段
- 依旧是回溯三部曲

## 代码
```cpp

```


# 78. 子集

## 题目

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

示例 1：

输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

## 解题思路

- 这个需要注意的一点是，不存在剪枝操作，也就是说遍历的树中的所有节点都要写在结果中
- 这题就是标准的套用模板，并且不需要做特殊操作，只需要遍历所有节点即可
- 一个小技巧：如果对递归和回溯感觉不清晰，可以在关键位置打印日志，然后根据日志逻辑理清递归嵌套的调用顺序。

## 代码
```cpp

```

# 90. 子集 II

## 题目

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

示例 1：

输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]

## 解题思路
- 去重之前记得排序，然后还是根据 nums[i] == nums[i-1] 判断是否重复，和之前的题目类似

## 代码
```cpp

```
