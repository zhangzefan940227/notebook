## Kotlin强制转换
将如下代码转换为kotlin代码
```java
LinearLayout linearLayout = (LinearLayout) mToast.getView();
TextView textView = (TextView) linearLayout.getChildAt(0);
textView.setTextSize(textSize);
```

```kotlin
val linearLayout = mToast.view as LinearLayout
val textView = linearLayout.getChildAt(0) as TextView
textView.textSize = textSize
```
这里的关键点是：

as关键字用于类型转换，等价于Java中的强制类型转换。
Kotlin中的val用于声明一个不可变的变量，等价于Java中的final修饰符。
方法调用和变量声明的语法有所不同，例如getChildAt(0)在Kotlin中直接调用，而view在Kotlin中是view而不是getView()。

linearLayout.getChildAt(0)在Android中是用于获取LinearLayout中第一个子视图的引用。
LinearLayout是一个可以水平或垂直排列子视图的布局容器。getChildAt(int index)方法接受一个整数参数index，返回该位置的子视图。

例如，如果你有一个LinearLayout包含了多个TextView，linearLayout.getChildAt(0)将返回第一个TextView，linearLayout.getChildAt(1)将返回第二个TextView，以此类推。


# @Data 使用
@Data 注解的主要作用是提高代码的简洁，使用这个注解可以省去代码中大量的get()、 set()、 toString()等方法；

# @AllArgsConstructor

@AllArgsConstructor 是 Lombok 提供的一个注解，用于自动生成一个包含所有参数的构造函数

```java
import lombok.AllArgsConstructor;

@AllArgsConstructor
public class MyClass {
    private String field1;
    private int field2;
    private double field3;
}
```
生成的构造函数如下：

```java
public MyClass(String field1, int field2, double field3) {
    this.field1 = field1;
    this.field2 = field2;
    this.field3 = field3;
}
```

# @NoArgsConstructor

用于自动生成午餐构造函数

# @Builder
```java
@Builder
public class User {
    private final Integer code = 200;
    private String username;
    private String password;
}

// 编译后：
public class User {
    private String username;
    private String password;
    User(String username, String password) {
        this.username = username; this.password = password;
    }
    public static User.UserBuilder builder() {
        return new User.UserBuilder();
    }

    public static class UserBuilder {
        private String username;
        private String password;
        UserBuilder() {}

        public User.UserBuilder username(String username) {
            this.username = username;
            return this;
        }
        public User.UserBuilder password(String password) {
            this.password = password;
            return this;
        }
        public User build() {
            return new User(this.username, this.password);
        }
        public String toString() {
            return "User.UserBuilder(username=" + this.username + ", password=" + this.password + ")";
        }
    }
}

// 可以进行如下方式调用
User.builder()
    .username("zhangsan")
    .password("abc")
    .build()
```

# 通过xml获取菜单列表项

```kotlin
/**
 * 通过xml文件获取菜单列表项
 * @param xml 传入的xml文件名称，包含后缀
 *
 */
@JvmStatic
@Throws(IOException::class, XmlPullParserException::class)
fun getMenuList(xml: InputStream?): List<MenuModel> {
    val menuList: MutableList<MenuModel> = ArrayList()
    var menuModel: MenuModel? = null
    val pullParser = Xml.newPullParser()
    try {
        //为PULL解析器设置要解析的XML数据
        pullParser.setInput(xml, "UTF-8")
        var event = pullParser.eventType
        while (event != XmlPullParser.END_DOCUMENT) {
            // when 等价于 switch
            when (event) {
                XmlPullParser.START_TAG -> {
                    when (pullParser.name) {
                        ITEM -> { menuModel = MenuModel() }
                        TITLE -> { menuModel?.setTitle(pullParser.nextText()) }
                        JUMP_TO_WHERE -> {
                            menuModel?.setJumpToWhere(Class.forName(pullParser.nextText()))
                        }
                    }
                }
                XmlPullParser.END_TAG -> {
                    if (ITEM == pullParser.name && menuModel != null) {
                        menuList.add(menuModel)
                        menuModel = null
                    }
                }
            }
            event = pullParser.next()
        }
    } catch (e: XmlPullParserException) {
        e.printStackTrace()
    } catch (e: ClassNotFoundException) {
        throw RuntimeException(e)
    }
    LogUtils.i(tag, menuList.toString())
    return menuList
}

```
