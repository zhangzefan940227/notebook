## 备忘
1. Android启动流程拆解：init zygote systemserver launcher activity
2. C++之旅 第三版
3. [代码随想录](https://www.programmercarl.com/) 算法
4. [leetcode 刷题顺序、按标签分类、科学刷题](https://blog.csdn.net/fengyuyeguirenenen/article/details/125099023?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170174413116800186543421%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170174413116800186543421&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125099023-null-null.142^v96^pc_search_result_base7&utm_term=LeetCode%E5%88%B7%E9%A2%98%E9%A1%BA%E5%BA%8F&spm=1018.2226.3001.4187)
5. [努比亚技术团队](https://www.jianshu.com/u/167b54662111) 性能优化

-------------------------------------------------------

## 博客
### 2024年1月3日
[leetcode-master/算法 - github](https://github.com/zhangzefan940227/leetcode-master/blob/master/problems/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.md)

[CS-Base/计算机网络 - github](https://github.com/xiaolincoder/CS-Base/blob/main/network/1_base/how_os_deal_network_package.md)

### 2023年12月28日
[java集合超详解](https://blog.csdn.net/feiyanaffection/article/details/81394745)

[数据结构——学习笔记——入门必看【建议收藏】_数据结构笔记-CSDN博客](https://liuxinlei.blog.csdn.net/article/details/104237990?ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdTE3MjM0MDUwL2NhdGVnb3J5XzkxMTkzMjIuaHRtbA%3D%3D)

[将近 10 万字爆肝 3 天整理 408 考研计算机网络复习笔记（更新中）_408笔记-CSDN博客](https://wrist.blog.csdn.net/article/details/123027380)

### 2023年12月21日
[Adroid RecyclerView adapter 封装](https://blog.csdn.net/JasonXu94/article/details/129658677?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170312909716800182782902%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170312909716800182782902&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-129658677-null-null.142^v96^pc_search_result_base7&utm_term=adapter%E5%B0%81%E8%A3%85&spm=1018.2226.3001.4187)

[Android中解析Xml文件并显示到文本框_android显示xml-CSDN博客](https://blog.csdn.net/qq_39125109/article/details/102467320?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170313925916800222899461%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=170313925916800222899461&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-102467320-null-null.142^v96^pc_search_result_base7&utm_term=android%20%E8%A7%A3%E6%9E%90%20asserts%20xml%E6%96%87%E4%BB%B6&spm=1018.2226.3001.4187)

[Android中 XML 自定义属性 详解_xml中bounds-CSDN博客](https://blog.csdn.net/weixin_45558166/article/details/110188808)

### 2023年12月20日
[计算机网络知识汇总](https://blog.csdn.net/qq_46101869/article/details/118108697?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170305446416800184194930%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170305446416800184194930&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118108697-null-null.142^v96^pc_search_result_base7&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&spm=1018.2226.3001.4187)

[全面&详细的面试指南：计算机网络篇 (附答案)](https://blog.csdn.net/carson_ho/article/details/123654331?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170306427016800225541283%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=170306427016800225541283&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-14-123654331-null-null.142^v96^pc_search_result_base7&utm_term=Android%E9%9D%A2%E8%AF%95%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&spm=1018.2226.3001.4187)

### 2023年12月18日
[Android Settings开发总结](https://blog.csdn.net/lanmengfenghe/article/details/114371759)

[简单案例理清Adapter、ViewHolder和RecyclerView之间的关系](https://blog.csdn.net/qq_42316421/article/details/106120039)
### 2023年12月15日
[android 仿微信demo————微信启动界面实现](https://blog.csdn.net/weixin_42768634/article/details/117873901?spm=1001.2014.3001.5501)

### 2023年12月13日
[图解 Android 事件分发机制 - 简书 (jianshu.com)](https://www.jianshu.com/p/e99b5e8bd67b)

[View体系与自定义View（四）—— View的事件分发机制_在自定义view基础上拦截触摸事件分发-CSDN博客](https://blog.csdn.net/xingyu19911016/article/details/120749887?ops_request_misc=&request_id=&biz_id=102&utm_term=view%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-120749887.142^v96^pc_search_result_base7&spm=1018.2226.3001.4187)

### 2023年12月10日
[Android RecyclerView使用简述
](https://blog.csdn.net/qq_38436214/article/details/126884365?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170222109116800188510706%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170222109116800188510706&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-126884365-null-null.142^v96^pc_search_result_base3&utm_term=Android%20RecyclerView&spm=1018.2226.3001.4187)

[【Android 】属性动画最全解析](https://blog.csdn.net/huweiliyi/article/details/105671079)

[看一遍就忘不了，事件分发机制分析](https://juejin.cn/post/6917056099069722632)


-------------------------------------------------------
# 知识点记录

**针对Fragement类型子界面，可用 adb logcat -s SubSettings 轻松查看进入了哪个界面。**

**遇到了一个Activity显示白屏的问题**
发现是重写错了onCreate方法，记录一下两个onCreate方法的区别
`onCreate(Bundle saveInstanceState)`
`Bundle savedInstanceState`是用来保存数据，`Activity`要是因为各种原因被销毁了，但是`Bundle savedInstanceState`不会销毁，重启的时候会在`onCreate`这个生命周期的第一个方法中保存下来，系统回调的时候给你用。
`oncreate(Bundle saveInstanceState,PersisitanbleBundle persistentState)`
可以将数据更加持久化的保存在`PersisitanbleBundle persistentState`中，同时记得在清单文件中的`Activity`属性中添加`android:persistableMode=“persistAcrossReboots”`，这样之后方可消除空白问题，要是想要获取`PersisitanbleBundle persistentState`数据重写下面方法就行了。
```java
@Override
public void onSaveInstanceState(@NonNull Bundle outState, @NonNull PersistableBundle outPersistentState) {
    super.onSaveInstanceState(outState, outPersistentState);
  
}
```

**FLAG_DISALLOW_INTERCEPT 标志位**
它主要是禁止 ViewGroup 拦截除了 DOWN 之外的事件，一般通过子 View.requestDisallowInterceptTouchEvent(...) 来设置。
```java
//ViewGroup.java dispatchTouchEvent(...)
final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0; // 2
```

**dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent**
对于ViewGroup
* dispatchTouchEvent
  * return super：正常走完事件流动路径
  * return true：事件停止传递，其他控件不再收到该事件
  * return false：事件停止向子`View`传递和分发，回传给父控件的`onTouchEvent`处理
    Activity的`dispatchTouchEvent`只有`return super.dispatchTouchEvent(ev)`才往下走，返回`true`或者`false`事件都会被消费
* onInterceptTouchEvent
  * 每个`ViewGroup`每次分发时，调用`onInterceptTouchEvent`判断是否需要拦截，也就是问问自己这个事件要不要自己来处理
  * return super/false：不会拦截，事件继续向子`View`的`dispatchTouchEvent`传递
  * return true：拦截事件，由自己处理
* onTouchEvent
  * return true：消费事件
  * return false：不消费事件，并让事件继续往父控件的方向从下往上流动
对于View
* dispatchTouchEvent
  * return super：`View`没有拦截器，View类的`super.dispatchTouchEvent()`默认实现会调用`View`自己的`onTouchEvent`
  * return true：事件终止，停止传递
  * return false：回溯到父类的`onTouchEvent`
对于`View.onTouchEvent`，`OnClickListerner.onClick`和`OnTouchListener.onTouch`的优先级
`View.dispatchTouchEvent` -> `OnTouchListener.onTouch` -> `View.onTouchEvent` -> `View.performClick` -> `OnClickListener.onClick`

# 计算机网络
# 1 计算机网络体系分层结构
- `OSI 体系结构`：应用层，表示层，会话层，运输层，网络层，数据链路层，物理层
- `TCP / IP 体系结构`：应用层，运输层（TCP或UDP），网际层（IP），网络接口层
- `五层协议体系结构`：应用层，运输层，网络层，数据链路层，物理层
# 网络协议
协议规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到信息或发生的事件所采取的“动作”（actions）。

三要素：
- 语法（用来规定信息格式）
- 语义（用来说明通信双方应当怎么做）
- 时序（详细说明事件的先后顺序）

分类：
- 网际层协议：IP协议、ICMP协议、ARP协议、RARP协议
- 传输层协议：TCP协议、UDP协议
- 应用层协议：FTP、Telnet、SMTP、HTTP、RIP、NFS、DNS

服务：
下层为上层提供的功能调用
```Bash
请求(Request) ：由服务用户发往服务提供者，请求完成某项工作。
指示(Indication) ：由服务提供者发往服务用户，指示用户做某件事情。
响应(Response) ：由服务用户发往服务提供者，作为对指示的响应。
证实(Confirmation) ：由服务提供者发往服务用户，作为对请求的证实。
```

# LeetCode

485
```java
    public int findMaxConsecutiveOnes(int[] nums) {
        int left = getStartLocation(0, nums);
        int sum = 0;
        for (int right = left; right < nums.length; right++) {
            if (nums[right] != 1) {
                left = getStartLocation(right, nums);
                right = left;
            } else {
                sum = Math.max(sum, right - left + 1);
            }
        }
        return sum;
    }
    public int getStartLocation(int start, int[] nums) {
        for (int i = start; i < nums.length; i++) {
            if (nums[i] == 1) {
                return i;
            }
        }
        return start;
    }
```

495
```java
    public int findPoisonedDuration(int[] timeSeries, int duration) {
        int i;
        for (i = 0; i < timeSeries.length; i++) {
            if ((i == timeSeries.length - 1) || (timeSeries[i] + duration - 1 < timeSeries[i + 1])) {
                break;
            }
        }
        return timeSeries[i] + duration - 1;
    }
```

# C++

### const 限定符

#### const 作用域
如果程序包含多个文件，则每个用了const对象的文件都必须能访问到它的初始值才行，也就必须在每一个用到变量的文件中都有对它的定义，同时避免对同一变量的重复定义，默认情况下，const 对象仅在文件内有效。
特殊的，当需要const在文件之间共享，则使用extern关键字实现。不管是声明还是定义都要添加。
```C++
// file_1.cc 定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize = fcn();
// file_1.h 头文件
extern const int bufSize;
```
上面的代码中，file_1.h头文件声明的作用是指明bufSize并非本文件独有，它的定义将在别处出现。

#### const引用
可以把引用绑定到const对象上，但是对常量的引用不能被用作修改它所绑定的对象。另外，允许将const引用绑定到一个普通对象上，如下示例中均是允许的。
```C++
const int ci = 42;
const int &r1 = ci; // 定义常量引用，引用对象为ci
//r1 = 1024; 错误，r1是对常量的引用，不可以修改
//int &r2 = ci; 错误，非常量引用不能指向一个常量对象

int i = 42;
const int &rr1 = i; //常量引用rr1绑定i
const int &rr2 = 42; //常量引用rr2绑定到常量上
const int &rr3 = rr1 * 2; //rr3也是一个常量引用
```
由上述可知，常量引用可能引用的并不是一个const对象，因此一般的，常量引用仅对引用可参与的操作做出限定，所以允许通过其他途径改变它的值。
```C++
int i = 42;
int &r1 = i;
const int &r2 = i;
r1 = 0; //r1非常量引用，可以改
//r2 = 0; 错误，r2是一个常量引用
```

#### 指针和const
**与引用一样**
1. 指针可以指向常量或非常量
2. 指向常量的指针不能改变所指对象的值
3. 要想存放常量对象的地址，只能使用指向常量的指针

```C++
const double pi = 3.14; //定义常量pi
//double *ptr = &pi; //错误，常量必须使用常量指针，ptr是个非常量指针
const double *cptr = &pi; //定义常量指针cptr指向pi
//*cptr = 42; //错误，cptr是个常量指针，不能赋值
```

**与引用不同的是**
const指针本身是一个对象，因此像其他对象类型一样，允许将指针本身定为常量。**常量指针必须初始化，初始化完成后，它的值就不能再改变了**

```C++
int num = 0;
int *const curr = &num;
const double const pi = 3.14;
const double *const pip = &pi;
```
常量指针pip指向的是常量，则pip本身存储的地址和pip所指向的对象均不可改变。
常量指针curr指向的是非常量，则可以通过curr去改变num的值。
```C++
//*pip = 2.22; //报错，pip指向的是一个常量
*curr = 0; //正确，把curr所指向的对象的值赋值为0
```

**【重要！！！】从上述例子可以看出，`*` 放在const关键字之前用以说明指针本身是一个常量，这样书写的含义是：不变的是指针本身，而非指向的那个值**
要想弄明白这些声明的含义，**最有效的办法是从右向左阅读**。离curr最近的符号是const，意味着curr本身是一个常量对象，下一个符号是*，意思是它是一个常量指针。
> 通过加括号的方式，更容易理解 `(int (*(const curr))) = num;` 但实际不能这么写。
