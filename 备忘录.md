## 备忘
1. Android启动流程拆解：init zygote systemserver launcher activity
2. C++之旅 第三版
3. [代码随想录](https://www.programmercarl.com/) 算法
4. [leetcode 刷题顺序、按标签分类、科学刷题](https://blog.csdn.net/fengyuyeguirenenen/article/details/125099023?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170174413116800186543421%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170174413116800186543421&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125099023-null-null.142^v96^pc_search_result_base7&utm_term=LeetCode%E5%88%B7%E9%A2%98%E9%A1%BA%E5%BA%8F&spm=1018.2226.3001.4187)
5. [努比亚技术团队](https://www.jianshu.com/u/167b54662111) 性能优化

-------------------------------------------------------

## 博客
### 2023年12月21日
[Adroid RecyclerView adapter 封装](https://blog.csdn.net/JasonXu94/article/details/129658677?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170312909716800182782902%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170312909716800182782902&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-129658677-null-null.142^v96^pc_search_result_base7&utm_term=adapter%E5%B0%81%E8%A3%85&spm=1018.2226.3001.4187)

[Android中解析Xml文件并显示到文本框_android显示xml-CSDN博客](https://blog.csdn.net/qq_39125109/article/details/102467320?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170313925916800222899461%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=170313925916800222899461&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-102467320-null-null.142^v96^pc_search_result_base7&utm_term=android%20%E8%A7%A3%E6%9E%90%20asserts%20xml%E6%96%87%E4%BB%B6&spm=1018.2226.3001.4187)

### 2023年12月20日
[计算机网络知识汇总](https://blog.csdn.net/qq_46101869/article/details/118108697?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170305446416800184194930%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170305446416800184194930&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118108697-null-null.142^v96^pc_search_result_base7&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&spm=1018.2226.3001.4187)

[全面&详细的面试指南：计算机网络篇 (附答案)](https://blog.csdn.net/carson_ho/article/details/123654331?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170306427016800225541283%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=170306427016800225541283&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-14-123654331-null-null.142^v96^pc_search_result_base7&utm_term=Android%E9%9D%A2%E8%AF%95%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&spm=1018.2226.3001.4187)

### 2023年12月18日
[Android Settings开发总结](https://blog.csdn.net/lanmengfenghe/article/details/114371759)

[简单案例理清Adapter、ViewHolder和RecyclerView之间的关系](https://blog.csdn.net/qq_42316421/article/details/106120039)
### 2023年12月15日
[android 仿微信demo————微信启动界面实现](https://blog.csdn.net/weixin_42768634/article/details/117873901?spm=1001.2014.3001.5501)

### 2023年12月13日
[图解 Android 事件分发机制 - 简书 (jianshu.com)](https://www.jianshu.com/p/e99b5e8bd67b)

[View体系与自定义View（四）—— View的事件分发机制_在自定义view基础上拦截触摸事件分发-CSDN博客](https://blog.csdn.net/xingyu19911016/article/details/120749887?ops_request_misc=&request_id=&biz_id=102&utm_term=view%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-120749887.142^v96^pc_search_result_base7&spm=1018.2226.3001.4187)

### 2023年12月10日
[Android RecyclerView使用简述
](https://blog.csdn.net/qq_38436214/article/details/126884365?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170222109116800188510706%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170222109116800188510706&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-126884365-null-null.142^v96^pc_search_result_base3&utm_term=Android%20RecyclerView&spm=1018.2226.3001.4187)

[【Android 】属性动画最全解析](https://blog.csdn.net/huweiliyi/article/details/105671079)

[看一遍就忘不了，事件分发机制分析](https://juejin.cn/post/6917056099069722632)


-------------------------------------------------------
# 知识点记录

**针对Fragement类型子界面，可用 adb logcat -s SubSettings 轻松查看进入了哪个界面。**

**遇到了一个Activity显示白屏的问题**
发现是重写错了onCreate方法，记录一下两个onCreate方法的区别
`onCreate(Bundle saveInstanceState)`
`Bundle savedInstanceState`是用来保存数据，`Activity`要是因为各种原因被销毁了，但是`Bundle savedInstanceState`不会销毁，重启的时候会在`onCreate`这个生命周期的第一个方法中保存下来，系统回调的时候给你用。
`oncreate(Bundle saveInstanceState,PersisitanbleBundle persistentState)`
可以将数据更加持久化的保存在`PersisitanbleBundle persistentState`中，同时记得在清单文件中的`Activity`属性中添加`android:persistableMode=“persistAcrossReboots”`，这样之后方可消除空白问题，要是想要获取`PersisitanbleBundle persistentState`数据重写下面方法就行了。
```java
@Override
    public void onSaveInstanceState(@NonNull Bundle outState, @NonNull PersistableBundle outPersistentState) {
        super.onSaveInstanceState(outState, outPersistentState);
      
    }
```

**FLAG_DISALLOW_INTERCEPT 标志位**
它主要是禁止 ViewGroup 拦截除了 DOWN 之外的事件，一般通过子 View.requestDisallowInterceptTouchEvent(...) 来设置。
```java
//ViewGroup.java dispatchTouchEvent(...)
final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0; // 2
```

**dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent**
对于ViewGroup
* dispatchTouchEvent
  * return super：正常走完事件流动路径
  * return true：事件停止传递，其他控件不再收到该事件
  * return false：事件停止向子`View`传递和分发，回传给父控件的`onTouchEvent`处理
    Activity的`dispatchTouchEvent`只有`return super.dispatchTouchEvent(ev)`才往下走，返回`true`或者`false`事件都会被消费
* onInterceptTouchEvent
  * 每个`ViewGroup`每次分发时，调用`onInterceptTouchEvent`判断是否需要拦截，也就是问问自己这个事件要不要自己来处理
  * return super/false：不会拦截，事件继续向子`View`的`dispatchTouchEvent`传递
  * return true：拦截事件，由自己处理
* onTouchEvent
  * return true：消费事件
  * return false：不消费事件，并让事件继续往父控件的方向从下往上流动
对于View
* dispatchTouchEvent
  * return super：`View`没有拦截器，View类的`super.dispatchTouchEvent()`默认实现会调用`View`自己的`onTouchEvent`
  * return true：事件终止，停止传递
  * return false：回溯到父类的`onTouchEvent`
对于`View.onTouchEvent`，`OnClickListerner.onClick`和`OnTouchListener.onTouch`的优先级
`View.dispatchTouchEvent` -> `OnTouchListener.onTouch` -> `View.onTouchEvent` -> `View.performClick` -> `OnClickListener.onClick`


# 竖直RecycleView
```java
public class VerticalRecycleViewActivity extends AppCompatActivity {
    RecyclerView mRecycleView;
    @Override
    public void onCreate(@Nullable Bundle savedInstanceState, @Nullable PersistableBundle persistentState) {
        setContentView(R.layout.activity_vertical);

        // 创建RecycleView对象
        mRecycleView = findViewById(R.id.vertical_rv);

        // 设置RecycleView的方向：水平/垂直
        LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false);

        // 设置LayoutManager
        mRecycleView.setLayoutManager(linearLayoutManager);

        // 设置Adapter绑定数据
        mRecycleView.setAdapter(new VerticalAdapter());
        super.onCreate(savedInstanceState, persistentState);
    }
}
```

Adapter
```java
public class VerticalAdapter extends RecyclerView.Adapter<VerticalViewHolder>{
    @NonNull
    @Override
    public VerticalViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {

        // LayoutInflater用于加载布局，from方法获取LayoutInflater对象
        LayoutInflater layoutInflater = LayoutInflater.from(parent.getContext());

        // 获取RecycleView中保存的每个item的布局
        RecyclerView itemView = (RecyclerView) layoutInflater.inflate(R.layout.item_vertical, parent, false);

        // 将itemView返回给ViewHolder
        return new VerticalViewHolder(itemView);
    }

    @Override
    public void onBindViewHolder(@NonNull VerticalViewHolder holder, int position) {

    }

    @Override
    public int getItemCount() {
        return 0;
    }
}

class VerticalViewHolder extends RecyclerView.ViewHolder {

    public VerticalViewHolder(@NonNull View itemView) {
        super(itemView);
    }
}
```

**item_vertical.xml**
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <androidx.cardview.widget.CardView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_margin="10dp" >

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <ImageView
                android:layout_width="100dp"
                android:layout_height="100dp"
                android:scaleType="centerCrop"
                android:src="@drawable/test" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_gravity="center_vertical"
                android:layout_marginStart="30dp"
                android:text="这是一段文本"
                android:textColor="#000000" />
        </LinearLayout>

    </androidx.cardview.widget.CardView>
</LinearLayout>
```
