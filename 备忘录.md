## 备忘
1. Android启动流程拆解：init zygote systemserver launcher activity
2. C++之旅 第三版


## 博客

### 2023年12月11日
[深入理解事件分发 ViewGroup.mFirstTouchTarget的设计](https://www.jianshu.com/p/5951ebdd2a7e)

[关于android事件分发中mFirstTouchTarget的理解](https://juejin.cn/post/7112606641006051364)

### 2023年12月10日
[Android RecyclerView使用简述
](https://blog.csdn.net/qq_38436214/article/details/126884365?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170222109116800188510706%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170222109116800188510706&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-126884365-null-null.142^v96^pc_search_result_base3&utm_term=Android%20RecyclerView&spm=1018.2226.3001.4187)

[Android属性动画解析](https://blog.csdn.net/huweiliyi/article/details/105671079)

[看一遍就忘不了，事件分发机制分析](https://juejin.cn/post/6917056099069722632)

[努比亚技术团队](https://www.jianshu.com/u/167b54662111)
> 性能优化

[leetcode 刷题顺序、按标签分类、科学刷题](https://blog.csdn.net/fengyuyeguirenenen/article/details/125099023?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170174413116800186543421%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170174413116800186543421&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125099023-null-null.142^v96^pc_search_result_base7&utm_term=LeetCode%E5%88%B7%E9%A2%98%E9%A1%BA%E5%BA%8F&spm=1018.2226.3001.4187)
> 算法相关

[代码随想录](https://www.programmercarl.com/)
> 算法相关
-------------------------------------------------------
# 笔记
# 属性动画用法
  对象动画（ObjectAnimator）
  值动画（ValueAnimator）
  PropertyValueHolder
  动画组合（AnimatorSet）
  差值器（Interpolator）
  估值器（TypeEvaluator）


## 对象动画（ObjectAnimator）
**ObjectAnimator基本用法**
```java
ImageView imageView = findViewById(R.id.imageView);
ObjectAnimator animator = ObjectAnimator.ofFloat(imageView, "alpha", 1f, 0f, 1f);
animator.setDuration(5000);
animator.start();
```

**ObjectAnimator其他方法**
```java
ImageView imageView = findViewById(R.id.imageView);
ObjectAnimator animator = ObjectAnimator.ofFloat(imageView, "alpha", 1f, 0f, 1f);
animator.setDuration(2000);

//动画延迟500ms执行
animator.setStartDelay(500);

//执行重复次数 +1
animator.setRepeatCount(3);

// 设置动画重复播放模式 RESTART -执行完一遍后重新执行
// REVERSE -执行完一遍后 从末位置往前执行
animator.setRepeatMode(ValueAnimator.RESTART);

//监听值变换
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
   @Override
   public void onAnimationUpdate(ValueAnimator animation) {
       Log.i("MainActivity","value：" +animation.getAnimatedValue());
   }
});
animator.start();
```

**通过XML实现ObjectAnimator**
1. 在`res`目录下新建`animator`文件夹
2. `animator`文件夹下创建动画XML文件，如`animator_alpha.xml`
3. 往该`xml`文件中输入如下代码

```xml
<?xml version="1.0" encoding="utf-8"?>
<objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"
    android:propertyName="alpha"
    android:valueFrom="1"
    android:valueTo="0"
    android:valueType="floatType" />
```
4. Java代码中通过加载该`xml`启动动画
```java
ImageView imageView = findViewById(R.id.imageView);
Animator animator = AnimatorInflater.loadAnimator(Main2Activity.this, R.animator.animator_alpha);
animator.setTarget(imageView);
animator.start();
```

## 值动画（ValueAnimator）
**ValueAnimator的核心方法如下**
```java
ValueAnimator ofFloat(float... values) -- 浮点型数值
ValueAnimator  ofInt(int... values) -- 整型数值
ValueAnimator  ofObject(TypeEvaluator evaluator, Object... values) -- 自定义对象类型
```
**在Activity中添加代码来使用回调监听值变化**
**具体imageView.setAlpha(currentValue)的效果需要实际测试一下，把这行注释掉是什么效果，因为看起来和对象动画没区别，为什么要多此一举设置这个值。**
```java
final ImageView imageView = findViewById(R.id.imageView);
ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);
anim.setDuration(5000);
anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
   @Override
   public void onAnimationUpdate(ValueAnimator animation) {
       float currentValue = (float) animation.getAnimatedValue();
       Log.d("MainActivity", "cuurent value is " + currentValue);
       imageView.setAlpha(currentValue);
   }
});
anim.start();
```

**PropertyValueHolder**
`PropertyValueHolder`可以让前面的一些动画同时执行。
```java
ImageView imageView = findViewById(R.id.imageView);
PropertyValuesHolder alphaProper = PropertyValuesHolder.ofFloat("alpha", 0.5f, 1f);
PropertyValuesHolder scaleXProper = PropertyValuesHolder.ofFloat("scaleX", 0f, 1f);
PropertyValuesHolder scaleYProper = PropertyValuesHolder.ofFloat("scaleY", 0f, 1f);
PropertyValuesHolder translationXProper = PropertyValuesHolder.ofFloat("translationX", -100, 100);
PropertyValuesHolder translationYProper = PropertyValuesHolder.ofFloat("translationY", -100, 100);
PropertyValuesHolder rotationProper = PropertyValuesHolder.ofFloat("rotation", 0, 360);
ValueAnimator animator = ObjectAnimator.ofPropertyValuesHolder(imageView, alphaProper,
        scaleXProper, scaleYProper,translationXProper,translationYProper,rotationProper);
animator.setDuration(5000);
animator.start();
```

## 动画组合（AnimatorSet）
`AnimatorSet`类不仅能让多个动画同时执行，还能让多个动画按一定的顺序执行，同时也能穿插多个动画同时执行。
主要方法
```java
after(Animator anim)  //将现有动画插入到传入的动画之后执行
after(long delay)     //将现有动画延迟指定毫秒后执行
before(Animator anim) //将现有动画插入到传入的动画之前执行
with(Animator anim)   //将现有动画和传入的动画同时执行
```
示例代码
```java
ImageView imageView = findViewById(R.id.imageView);

// 获取多个动画对象
ObjectAnimator rotate = ObjectAnimator.ofFloat(imageView, "rotation", 0f, 360f);
ObjectAnimator translationX = ObjectAnimator.ofFloat(imageView, "translationX", -100, 100f);
ObjectAnimator translationY = ObjectAnimator.ofFloat(imageView, "translationY", -100, 100f);
ObjectAnimator scaleX = ObjectAnimator.ofFloat(imageView, "scaleX", 0, 1f);
ObjectAnimator scaleY = ObjectAnimator.ofFloat(imageView, "scaleY", 0, 1f);
ObjectAnimator alpha = ObjectAnimator.ofFloat(imageView, "alpha", 1f, 0f, 1f);

// 设置AnimatorSet
AnimatorSet animSet = new AnimatorSet();
animSet.play(rotate)
       .with(alpha)
       .after(scaleX)
       .before(translationX)
       .after(1000)
       .before(translationY)
       .with(scaleY);
animSet.setDuration(5000);
animSet.start();
```

## 差值器（Interpolator）
前面的动画属性的变换都是均匀变换，可以通过`差值器（Interpolator）`来控制值变化的速率
```java
ImageView imageView = findViewById(R.id.imageView);
ObjectAnimator animator = ObjectAnimator.ofFloat(imageView, "alpha",  0f, 1f);
animator.setDuration(5000);
//加速差值器，参数越大，速度越来越快
animator.setInterpolator(new AccelerateInterpolator(5));
animator.start();
```

|动画名称	|效果|
|  ----  | ----  |
|AccelerateInterpolator	|加速查值器，参数越大，速度越来越快|
|DecelerateInterpolator	|减速差值起，和加速查值器相反|
|AccelerateDecelerateInterpolator	|先加速后减速|
|AnticipateInterpolator	|先后退在加速前进|
|AnticipateOvershootInterpolator	|以X/Y轴为轴的旋转度数|
|BounceInterpolator	|弹球效果插值|
|CycleInterpolator	|周期运动插值|
|LinearInterpolator	|匀速插值|
|OvershootInterpolator	|先快速完成动画，再回到结束样式|
